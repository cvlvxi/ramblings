(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0cfe38"],{6646:function(e,a,t){"use strict";t.r(a);var s=function(){var e=this,a=e.$createElement;e._self._c;return e._m(0)},r=[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("section",[t("h1",[e._v("Vulkan")]),t("ul",[t("li",[t("a",{attrs:{href:"#Initialization"}},[e._v("Initialization")]),t("ul",[t("li",[t("a",{attrs:{href:"#VulkanObjectsMethods"}},[e._v("Vulkan Objects Methods")])]),t("li",[t("a",{attrs:{href:"#GLFW"}},[e._v("GLFW")])]),t("li",[t("a",{attrs:{href:"#mainloop"}},[e._v("mainloop")])])])]),t("li",[t("a",{attrs:{href:"#Instance"}},[e._v("Instance")]),t("ul",[t("li",[t("a",{attrs:{href:"#VulkanExtensions"}},[e._v("Vulkan Extensions")])]),t("li",[t("a",{attrs:{href:"#CommonPatternforCreatingVulkanObjects"}},[e._v("Common Pattern for Creating Vulkan Objects")])]),t("li",[t("a",{attrs:{href:"#VkResultfromvulkanmethods"}},[e._v("VkResult from vulkan methods")])]),t("li",[t("a",{attrs:{href:"#CleaningupVKObjects"}},[e._v("Cleaning up VK Objects")])])])]),t("li",[t("a",{attrs:{href:"#ValidationLayer"}},[e._v("Validation Layer")]),t("ul",[t("li",[t("a",{attrs:{href:"#TypesofValidationLayers"}},[e._v("Types of Validation Layers")])]),t("li",[t("a",{attrs:{href:"#VK_LAYER_KHRONOS_validation"}},[e._v("VK_LAYER_KHRONOS_validation")])])])]),t("li",[t("a",{attrs:{href:"#PhysicalDevicesQueueFamilies"}},[e._v("Physical Devices & Queue Families")]),t("ul",[t("li",[t("a",{attrs:{href:"#GPUDevice"}},[e._v("GPU Device")])]),t("li",[t("a",{attrs:{href:"#Arrayofalldevices"}},[e._v("Array of all devices")])]),t("li",[t("a",{attrs:{href:"#Checkwhatstuffdevicesupports"}},[e._v("Check what stuff device supports")])])])]),t("li",[t("a",{attrs:{href:"#QueueFamilies"}},[e._v("Queue Families")]),t("ul",[t("li",[t("a",{attrs:{href:"#findQueueFamilies"}},[e._v("findQueueFamilies")])])])]),t("li",[t("a",{attrs:{href:"#LogicalDevicesandQueues"}},[e._v("Logical Devices and Queues")])]),t("li",[t("a",{attrs:{href:"#Presenting:Surfaces"}},[e._v("Presenting: Surfaces")]),t("ul",[t("li",[t("a",{attrs:{href:"#Morequeues"}},[e._v("More queues")])])])]),t("li",[t("a",{attrs:{href:"#SwapChain"}},[e._v("SwapChain")]),t("ul",[t("li",[t("a",{attrs:{href:"#Enabling"}},[e._v("Enabling")])]),t("li",[t("a",{attrs:{href:"#CompatibilitywithWindowSurface"}},[e._v("Compatibility with Window Surface")])]),t("li",[t("a",{attrs:{href:"#SwapChainSettings"}},[e._v("Swap Chain Settings")]),t("ul",[t("li",[t("a",{attrs:{href:"#SurfaceFormat"}},[e._v("Surface Format")])]),t("li",[t("a",{attrs:{href:"#PresentationMode"}},[e._v("Presentation Mode")])]),t("li",[t("a",{attrs:{href:"#SwapExtent"}},[e._v("Swap Extent")])])])]),t("li",[t("a",{attrs:{href:"#CreatingSwapChain"}},[e._v("Creating Swap Chain")])])])]),t("li",[t("a",{attrs:{href:"#ImageViews"}},[e._v("Image Views")]),t("ul",[t("li",[t("a",{attrs:{href:"#VKImage"}},[e._v("VKImage")])]),t("li",[t("a",{attrs:{href:"#VKImageView"}},[e._v("VKImageView")])]),t("li",[t("a",{attrs:{href:"#CreatingImageView"}},[e._v("Creating ImageView")])]),t("li",[t("a",{attrs:{href:"#viewType"}},[e._v("viewType")])]),t("li",[t("a",{attrs:{href:"#format"}},[e._v("format")])]),t("li",[t("a",{attrs:{href:"#componentsswizzling"}},[e._v("components & swizzling")])]),t("li",[t("a",{attrs:{href:"#subresourceRange"}},[e._v("subresourceRange")])]),t("li",[t("a",{attrs:{href:"#CreatingtheImageViewvkCreateImageView"}},[e._v("Creating the ImageView vkCreateImageView")])])])]),t("li",[t("a",{attrs:{href:"#GraphicsPipeline"}},[e._v("Graphics Pipeline")]),t("ul",[t("li",[t("a",{attrs:{href:"#InputAssembler"}},[e._v("Input Assembler")])]),t("li",[t("a",{attrs:{href:"#VertexShader"}},[e._v("Vertex Shader")])]),t("li",[t("a",{attrs:{href:"#TesselationShaders"}},[e._v("Tesselation Shaders")])]),t("li",[t("a",{attrs:{href:"#GeometryShader"}},[e._v("Geometry Shader")])]),t("li",[t("a",{attrs:{href:"#Rasterisationstage"}},[e._v("Rasterisation stage")])]),t("li",[t("a",{attrs:{href:"#FragmentShader"}},[e._v("Fragment Shader")])]),t("li",[t("a",{attrs:{href:"#ColorBlending"}},[e._v("Color Blending")])])])]),t("li",[t("a",{attrs:{href:"#GraphicsPipelineMutability"}},[e._v("Graphics Pipeline Mutability")]),t("ul",[t("li",[t("a",{attrs:{href:"#Immutable"}},[e._v("Immutable")])]),t("li",[t("a",{attrs:{href:"#ShadowMaps"}},[e._v("Shadow Maps")])])])]),t("li",[t("a",{attrs:{href:"#ShaderModules"}},[e._v("Shader Modules")]),t("ul",[t("li",[t("a",{attrs:{href:"#SPIR-V"}},[e._v("SPIR-V")])]),t("li",[t("a",{attrs:{href:"#Whybytecode"}},[e._v("Why bytecode?")])]),t("li",[t("a",{attrs:{href:"#ProblemswithGLSLHLSL"}},[e._v("Problems with GLSL/HLSL")])]),t("li",[t("a",{attrs:{href:"#CompilingvsRuntime"}},[e._v("Compiling vs Runtime")])]),t("li",[t("a",{attrs:{href:"#Tools"}},[e._v("Tools")])]),t("li",[t("a",{attrs:{href:"#Glslbasics"}},[e._v("Glsl basics")])]),t("li",[t("a",{attrs:{href:"#VertexShader-1"}},[e._v("Vertex Shader")])]),t("li",[t("a",{attrs:{href:"#ClipCoordinateHomogeneousCoordinates"}},[e._v("Clip Coordinate & Homogeneous Coordinates")])]),t("li",[t("a",{attrs:{href:"#Z-Coordinate"}},[e._v("Z-Coordinate")])]),t("li",[t("a",{attrs:{href:"#GL_ARB_separate_shader_objects"}},[e._v("GL_ARB_separate_shader_objects")])]),t("li",[t("a",{attrs:{href:"#Sendingoutattributeswithlayout"}},[e._v("Sending out attributes with layout")])]),t("li",[t("a",{attrs:{href:"#gl_Positionisaspecialattributefromvertexshader"}},[e._v("gl_Position is a special attribute from vertex shader")])]),t("li",[t("a",{attrs:{href:"#inandoutparams"}},[e._v("in and out params")])])])]),t("li",[t("a",{attrs:{href:"#ShaderModulesVKShaderModule"}},[e._v("ShaderModules (VKShaderModule)")]),t("ul",[t("li",[t("a",{attrs:{href:"#SPIRVuseinGraphicsPipeline"}},[e._v("SPIRV use in Graphics Pipeline")])]),t("li",[t("a",{attrs:{href:"#VkPipelineShaderStageCreateInfo"}},[e._v("VkPipelineShaderStageCreateInfo")])]),t("li",[t("a",{attrs:{href:"#pSpecializationInfo"}},[e._v("pSpecializationInfo")])])])]),t("li",[t("a",{attrs:{href:"#Fixedfunctions"}},[e._v("Fixed functions")]),t("ul",[t("li",[t("a",{attrs:{href:"#VertexInput"}},[e._v("Vertex Input")])]),t("li",[t("a",{attrs:{href:"#VkPipelineInputAssemblyStateCreateInfo"}},[e._v("VkPipelineInputAssemblyStateCreateInfo")])]),t("li",[t("a",{attrs:{href:"#ViewPortsandScissors"}},[e._v("ViewPorts and Scissors")])]),t("li",[t("a",{attrs:{href:"#FilteringimagewithScissorRectanglesViewport"}},[e._v("Filtering image with Scissor Rectangles + Viewport")])]),t("li",[t("a",{attrs:{href:"#Rasterizer"}},[e._v("Rasterizer")])]),t("li",[t("a",{attrs:{href:"#Nonfillmodesneed"}},[e._v("Non fill modes need")])]),t("li",[t("a",{attrs:{href:"#Faceculling"}},[e._v("Face culling")])]),t("li",[t("a",{attrs:{href:"#Depthproperties"}},[e._v("Depth properties")])]),t("li",[t("a",{attrs:{href:"#Multisamplingforanti-aliasing"}},[e._v("Multisampling for anti-aliasing")])]),t("li",[t("a",{attrs:{href:"#Depthandstenciltesting"}},[e._v("Depth and stencil testing")])]),t("li",[t("a",{attrs:{href:"#ColorBlending-1"}},[e._v("Color Blending")])]),t("li",[t("a",{attrs:{href:"#DynamicStatechangingpipelinewithoutrestart"}},[e._v("Dynamic State (changing pipeline without restart)")])]),t("li",[t("a",{attrs:{href:"#Pipelinelayout"}},[e._v("Pipeline layout")])])])]),t("li",[t("a",{attrs:{href:"#RenderPasses"}},[e._v("Render Passes")]),t("ul",[t("li",[t("a",{attrs:{href:"#SingleColorBufferattachment"}},[e._v("Single Color Buffer attachment")])]),t("li",[t("a",{attrs:{href:"#Triangle"}},[e._v("Triangle")])]),t("li",[t("a",{attrs:{href:"#ColorAttachmentLayout"}},[e._v("Color Attachment Layout")]),t("ul",[t("li",[t("a",{attrs:{href:"#InitialLayout"}},[e._v("Initial Layout")])])])]),t("li",[t("a",{attrs:{href:"#FinalLayout"}},[e._v("Final Layout")])]),t("li",[t("a",{attrs:{href:"#Subpassesandattachmentreferences"}},[e._v("Subpasses and attachment references")])]),t("li",[t("a",{attrs:{href:"#attachment"}},[e._v("attachment")])]),t("li",[t("a",{attrs:{href:"#SubpassDescription"}},[e._v("Subpass Description")])]),t("li",[t("a",{attrs:{href:"#OtherattachmentTypes"}},[e._v("Other attachment Types")])])])]),t("li",[t("a",{attrs:{href:"#RenderPass"}},[e._v("Render Pass")])]),t("li",[t("a",{attrs:{href:"#Drawing:FrameBuffers"}},[e._v("Drawing: Frame Buffers")]),t("ul",[t("li",[t("a",{attrs:{href:"#FrameBuffercontains"}},[e._v("FrameBuffer contains")])]),t("li",[t("a",{attrs:{href:"#CreatingFrameBuffersfromImageViews"}},[e._v("Creating FrameBuffers from ImageViews")])])])]),t("li",[t("a",{attrs:{href:"#CommandBuffers"}},[e._v("Command Buffers")]),t("ul",[t("li",[t("a",{attrs:{href:"#PrimarySecondarycommandbuffer"}},[e._v("Primary / Secondary command buffer?")])]),t("li",[t("a",{attrs:{href:"#CommandBufferRecording"}},[e._v("Command Buffer Recording")])]),t("li",[t("a",{attrs:{href:"#StartRenderPass"}},[e._v("Start Render Pass")])]),t("li",[t("a",{attrs:{href:"#RenderPassvkCmd-BeginDrawingCommand"}},[e._v("Render Pass vkCmd - Begin Drawing Command")])]),t("li",[t("a",{attrs:{href:"#EndingtheRenderPassCmd"}},[e._v("Ending the Render Pass Cmd")])])])]),t("li",[t("a",{attrs:{href:"#VertexBuffers"}},[e._v("Vertex Buffers")]),t("ul",[t("li",[t("a",{attrs:{href:"#NeedtospecifytheBindingDescription"}},[e._v("Need to specify the "),t("code",{pre:!0},[e._v("Binding Description")])])]),t("li",[t("a",{attrs:{href:"#AttributeDescription"}},[e._v("Attribute Description")])])])])]),t("p",[e._v("From the official documentation "),t("a",{attrs:{href:"https://vulkan-tutorial.com/en"}},[e._v("here")])]),t("h2",[t("a",{attrs:{name:"Initialization"}}),e._v("Initialization")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Base_code"}},[e._v("Doc: Base Code")])])]),t("h3",[t("a",{attrs:{name:"VulkanObjectsMethods"}}),e._v("Vulkan Objects Methods")]),t("ul",[t("li",[e._v("vkCreateXXX")]),t("li",[e._v("vkAllocateXXX")]),t("li",[e._v("vkDestroyXXX")]),t("li",[e._v("vkFreeXXX")]),t("li",[e._v("They all share one parameter "),t("code",{pre:!0},[e._v("pAllocator")]),e._v(" default use "),t("code",{pre:!0},[e._v("nullptr")]),t("ul",[t("li",[e._v("This gets a custom callback for custom memory allocation")])])])]),t("h3",[t("a",{attrs:{name:"GLFW"}}),e._v("GLFW")]),t("ul",[t("li",[e._v("Window stuff")]),t("li",[e._v("glfwInit()")]),t("li",[e._v("Disable OpenGL: `glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);")]),t("li",[e._v("Creating window")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// width, height, title, which window to start on ")]),e._v("\nwindow = glfwCreateWindow("),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("800")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("600")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"Vulkan"')]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(");\n")])]),t("h3",[t("a",{attrs:{name:"mainloop"}}),e._v("mainloop")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("    "),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("mainLoop")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("while")]),e._v(" (!glfwWindowShouldClose(window)) {\n            glfwPollEvents();\n        }\n    }\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"Instance"}}),e._v("Instance")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Instance"}},[e._v("Doc: Instance")])]),t("li",[e._v("VKInstance requires "),t("code",{pre:!0},[e._v("#include <vulkan/vulkan.h>")])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("    "),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("createInstance")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n        VkApplicationInfo appInfo{};\n        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;\n        appInfo.pApplicationName = "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"Hello Triangle"')]),e._v(";\n        appInfo.applicationVersion = VK_MAKE_VERSION("),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(");\n        appInfo.pEngineName = "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"No Engine"')]),e._v(";\n        appInfo.engineVersion = VK_MAKE_VERSION("),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(");\n        appInfo.apiVersion = VK_API_VERSION_1_0;\n\n        VkInstanceCreateInfo createInfo{};\n        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n        createInfo.pApplicationInfo = &appInfo;\n\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v(" glfwExtensionCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("char")]),e._v("** glfwExtensions;\n        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);\n\n        createInfo.enabledExtensionCount = glfwExtensionCount;\n        createInfo.ppEnabledExtensionNames = glfwExtensions;\n\n        createInfo.enabledLayerCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkCreateInstance(&createInfo, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &instance) != VK_SUCCESS) {\n            "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create instance!"')]),e._v(");\n        }\n")])]),t("h3",[t("a",{attrs:{name:"VulkanExtensions"}}),e._v("Vulkan Extensions")]),t("ul",[t("li",[e._v("Vulkan needs to enable extensions for window drawing from glfw")]),t("li",[e._v("See this")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v(" glfwExtensionCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("char")]),e._v("** glfwExtensions;\n        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);\n        createInfo.enabledExtensionCount = glfwExtensionCount;\n        createInfo.ppEnabledExtensionNames = glfwExtensions;\n")])]),t("h3",[t("a",{attrs:{name:"CommonPatternforCreatingVulkanObjects"}}),e._v("Common Pattern for Creating Vulkan Objects")]),t("ul",[t("li",[e._v("Pointer to struct with creation info")]),t("li",[e._v("Pointer to custom allocator callbacks, always nullptr in this tutorial")]),t("li",[e._v("Pointer to the variable that stores the handle to the new object")]),t("li",[e._v("e.g. "),t("code",{pre:!0},[e._v("VkResult result = vkCreateInstance(&createInfo, nullptr, &instance);")])])]),t("h3",[t("a",{attrs:{name:"VkResultfromvulkanmethods"}}),e._v("VkResult from vulkan methods")]),t("ul",[t("li",[e._v("that is either VK_SUCCESS or an error code")]),t("li",[e._v("Can check this")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkCreateInstance(&createInfo, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &instance) != VK_SUCCESS) {\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create instance!"')]),e._v(");\n}\n")])]),t("h3",[t("a",{attrs:{name:"CleaningupVKObjects"}}),e._v("Cleaning up VK Objects")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("cleanup")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    vkDestroyInstance(instance, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(");\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"ValidationLayer"}}),e._v("Validation Layer")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Validation_layers"}},[e._v("Doc: Validation Layer")])]),t("li",[e._v("Vulkan does "),t("code",{pre:!0},[e._v("VERY LITTLE ERROR CHECKING")]),e._v(" which can result in crashes or undefined behaviour")]),t("li",[e._v("Validation Layers "),t("code",{pre:!0},[e._v("hook into Vulkan function calls")]),e._v(" to apply additional operations such as "),t("ul",[t("li",[e._v("Checking the values of parameters against the specification to detect misuse")]),t("li",[e._v("Tracking creation and destruction of objects to find resource leaks")]),t("li",[e._v("Checking thread safety by tracking the threads that calls originate from")]),t("li",[e._v("Logging every call and its parameters to the standard output")]),t("li",[e._v("Tracing Vulkan calls for profiling and replaying")])])])]),t("h3",[t("a",{attrs:{name:"TypesofValidationLayers"}}),e._v("Types of Validation Layers")]),t("ul",[t("li",[e._v("two different types of validation layers in Vulkan: instance and device specific.")])]),t("h3",[t("a",{attrs:{name:"VK_LAYER_KHRONOS_validation"}}),e._v("VK_LAYER_KHRONOS_validation")]),t("ul",[t("li",[e._v("All standard validations are bundled in this")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("char")]),e._v("*> validationLayers = {\n    "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"VK_LAYER_KHRONOS_validation"')]),e._v("\n};\n\n"),t("span",{pre:!0,attrs:{class:"hljs-meta"}},[e._v("#"),t("span",{pre:!0,attrs:{class:"hljs-meta-keyword"}},[e._v("ifdef")]),e._v(" NDEBUG")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("bool")]),e._v(" enableValidationLayers = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("false")]),e._v(";\n"),t("span",{pre:!0,attrs:{class:"hljs-meta"}},[e._v("#"),t("span",{pre:!0,attrs:{class:"hljs-meta-keyword"}},[e._v("else")])]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("bool")]),e._v(" enableValidationLayers = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("true")]),e._v(";\n"),t("span",{pre:!0,attrs:{class:"hljs-meta"}},[e._v("#"),t("span",{pre:!0,attrs:{class:"hljs-meta-keyword"}},[e._v("endif")])]),e._v("\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"PhysicalDevicesQueueFamilies"}}),e._v("Physical Devices & Queue Families")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families"}},[e._v("Docs: Physical Devices & Queue Families")])])]),t("h3",[t("a",{attrs:{name:"GPUDevice"}}),e._v("GPU Device")]),t("ul",[t("li",[e._v("The graphics card that we'll end up selecting will be stored in a VkPhysicalDevice handle")]),t("li",[t("code",{pre:!0},[e._v("VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;")]),t("ul",[t("li",[e._v("This object will be implicitly destroyed when the VkInstance is destroyed,")])])])]),t("h3",[t("a",{attrs:{name:"Arrayofalldevices"}}),e._v("Array of all devices")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-C++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v(" deviceCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n"),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<VkPhysicalDevice> "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("devices")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("(deviceCount)")])]),e._v(";\nvkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());\n")])]),t("h3",[t("a",{attrs:{name:"Checkwhatstuffdevicesupports"}}),e._v("Check what stuff device supports")]),t("ul",[t("li",[e._v("See vkGetPhysicalDeviceProperties.")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPhysicalDeviceProperties deviceProperties;\nvkGetPhysicalDeviceProperties(device, &deviceProperties);\n")])]),t("h2",[t("a",{attrs:{name:"QueueFamilies"}}),e._v("Queue Families")]),t("ul",[t("li",[e._v("Different queue families have different functionalities")]),t("li",[e._v("e.g. a queue family that only allows processing of compute commands or one that only allows memory transfer related commands.")])]),t("h3",[t("a",{attrs:{name:"findQueueFamilies"}}),e._v("findQueueFamilies")]),t("ul",[t("li",[e._v("Look for queue with supported Graphics commands")]),t("li",[e._v("Use std optional to say whether it exists or not")])]),t("hr"),t("h2",[t("a",{attrs:{name:"LogicalDevicesandQueues"}}),e._v("Logical Devices and Queues")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Logical_device_and_queues"}},[e._v("Logical Devices and Queues")])]),t("li",[e._v("After selecting a physical device to use we need to set up a logical device to interface with it")])]),t("hr"),t("h2",[t("a",{attrs:{name:"Presenting:Surfaces"}}),e._v("Presenting: Surfaces")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface"}},[e._v("Surfaces")])]),t("li",[e._v("VkSurfaceKHR surface;")]),t("li",[e._v("Comes with glfw as an extension in order to talk to vulkan")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n    "),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("createSurface")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (glfwCreateWindowSurface(instance, window, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &surface) != VK_SUCCESS) {\n            "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create window surface!"')]),e._v(");\n        }\n    }\n")])]),t("h3",[t("a",{attrs:{name:"Morequeues"}}),e._v("More queues")]),t("ul",[t("li",[e._v("Present Family queue")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkQueue graphicsQueue;\nVkQueue presentQueue;\n\n"),t("span",{pre:!0,attrs:{class:"hljs-class"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("struct")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("QueueFamilyIndices")]),e._v(" {")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::optional<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v("> graphicsFamily;\n    "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::optional<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v("> presentFamily;\n\n    "),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("bool")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("isComplete")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("return")]),e._v(" graphicsFamily.has_value() && presentFamily.has_value();\n    }\n};\n")])]),t("ul",[t("li",[e._v("Present may not be applicable think server side gpu")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n            VkBool32 presentSupport = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("false")]),e._v(";\n            vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);\n\n            "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (presentSupport) {\n                indices.presentFamily = i;\n            }\n")])]),t("ul",[t("li",[e._v("Create the new queue for the "),t("code",{pre:!0},[e._v("logical device")]),e._v(" (1to1 with physical gfx device)")])]),t("hr"),t("h2",[t("a",{attrs:{name:"SwapChain"}}),e._v("SwapChain")]),t("h3",[t("a",{attrs:{name:"Enabling"}}),e._v("Enabling")]),t("p",[e._v("just like validation layer extensions swapchain is an extension to vulkan")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("char")]),e._v("*> validationLayers = {\n    "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"VK_LAYER_KHRONOS_validation"')]),e._v("\n};\n\n"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("char")]),e._v("*> deviceExtensions = {\n    VK_KHR_SWAPCHAIN_EXTENSION_NAME\n};\n")])]),t("ul",[t("li",[e._v("Enabling requires adding this to the Logical Device creation")]),t("li",[e._v("In createLogicalDevice()")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n        createInfo.enabledExtensionCount = "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("static_cast")]),e._v("<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v(">(deviceExtensions."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("());\n        createInfo.ppEnabledExtensionNames = deviceExtensions.data();\n")])]),t("h3",[t("a",{attrs:{name:"CompatibilitywithWindowSurface"}}),e._v("Compatibility with Window Surface")]),t("ul",[t("li",[e._v("Swap chain may not be compatible with the glfw window surface so we need to query the following: "),t("ul",[t("li",[e._v("Basic surface capabilities (min/max number of images in swap chain, min/max width and height of images)")]),t("li",[e._v("Surface formats (pixel format, color space)")]),t("li",[e._v("Available presentation modes")])])])]),t("h3",[t("a",{attrs:{name:"SwapChainSettings"}}),e._v("Swap Chain Settings")]),t("ul",[t("li",[e._v("Surface format (color depth)")]),t("li",[e._v('Presentation mode (conditions for "swapping" images to the screen)')]),t("li",[e._v("Swap extent (resolution of images in swap chain)")])]),t("h4",[t("a",{attrs:{name:"SurfaceFormat"}}),e._v("Surface Format")]),t("ul",[t("li",[e._v("e.g. Surface can support color channels and types")]),t("li",[t("code",{pre:!0},[e._v("VK_FROMAT_B8G8R8A_SRGB")]),e._v("a")]),t("li",[e._v("Can do a ranking of different formats to choose which one is best")])]),t("h4",[t("a",{attrs:{name:"PresentationMode"}}),e._v("Presentation Mode")]),t("ul",[t("li",[t("p",[e._v("Presents the actual conditions for showing images to the screen")])]),t("li",[t("p",[e._v("Modes:")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("VK_PRESENT_MODE_IMMEDIATE_KHR")]),e._v(": Images submitted right away to screen without tearing")]),t("li",[t("code",{pre:!0},[e._v("VK_PRESENT_MODE_FIFO_KHR")]),e._v(": FIFO queue similar to vertical sync")]),t("li",[t("code",{pre:!0},[e._v("VK_PRESENT_MODE_FIFO_RELAXED_KHR")])]),t("li",[t("code",{pre:!0},[e._v("VK_PRESENT_MODE_MAILBOX_KHR")]),e._v(": triple bufferring")])])]),t("li",[t("p",[t("code",{pre:!0},[e._v("VK_PRESENT_MODE_FIFO_KHR")]),e._v(" guaranteed to be there")])])]),t("h4",[t("a",{attrs:{name:"SwapExtent"}}),e._v("Swap Extent")]),t("ul",[t("li",[e._v("Resolution of swap chain images")]),t("li",[e._v("Read up on it more "),t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Presentation/Swap_chain"}},[e._v("here")])])]),t("h3",[t("a",{attrs:{name:"CreatingSwapChain"}}),e._v("Creating Swap Chain")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("createSwapChain")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);\n\n    VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);\n    VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);\n    VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);\n}\n")])]),t("ul",[t("li",[e._v("set min amount of images + 1 (+1) as acquiring images setting this is better")]),t("li",[e._v("set max image count")]),t("li",[e._v("create swapchaininfo struct")]),t("li",[e._v("Set the surface format and colorspace properties")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("createInfo.imageFormat = surfaceFormat.format;\ncreateInfo.imageColorSpace = surfaceFormat.colorSpace;\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"ImageViews"}}),e._v("Image Views")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Presentation/Image_views"}},[e._v("Image Views")])])]),t("h3",[t("a",{attrs:{name:"VKImage"}}),e._v("VKImage")]),t("ul",[t("li",[e._v("Used in the swap chain")]),t("li",[e._v("In order to use it we need to create a "),t("code",{pre:!0},[e._v("VKImageView")]),e._v(" object")])]),t("h3",[t("a",{attrs:{name:"VKImageView"}}),e._v("VKImageView")]),t("ul",[t("li",[e._v("View into an Image describes: "),t("ul",[t("li",[e._v("How to access the image")]),t("li",[e._v("Which part of the image to access")])])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<VkImageView> swapChainImageViews;\n\n"),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("createImageViews")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    swapChainImageViews.resize(swapChainImages."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("());\n    ...\n}\n\n")])]),t("ul",[t("li",[e._v("Need to destroy when instance is destroyed")])]),t("h3",[t("a",{attrs:{name:"CreatingImageView"}}),e._v("Creating ImageView")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("for")]),e._v(" ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("size_t")]),e._v(" i = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; i < swapChainImages."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("(); i++) {\n            VkImageViewCreateInfo createInfo{};\n            createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;\n            createInfo."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("image")]),e._v(" = swapChainImages[i];\n")])]),t("p",[e._v("sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO")]),t("p",[e._v("Iterating through each swapChainimage... which is "),t("code",{pre:!0},[e._v("std::vector<VkImage> swapChainImages;")])]),t("h3",[t("a",{attrs:{name:"viewType"}}),e._v("viewType")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;\n")])]),t("p",[e._v("What's a view type?")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("typedef")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("enum")]),e._v(" VkImageViewType {\n    VK_IMAGE_VIEW_TYPE_1D = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_2D = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_3D = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_CUBE = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("3")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_1D_ARRAY = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("4")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_2D_ARRAY = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("5")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("6")]),e._v(",\n    VK_IMAGE_VIEW_TYPE_MAX_ENUM = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0x7FFFFFFF")]),e._v("\n} VkImageViewType;\n")])]),t("h3",[t("a",{attrs:{name:"format"}}),e._v("format")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("    VkFormat swapChainImageFormat;\n")])]),t("p",[e._v("Created in the swapchain")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("        swapChainImageFormat = surfaceFormat.format;\n        swapChainExtent = extent;\n")])]),t("p",[e._v("Grabbed from the surfaceFormat (glfw)")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("        VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);\n")])]),t("p",[e._v("here")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n    "),t("span",{pre:!0,attrs:{class:"hljs-function"}},[e._v("VkSurfaceFormatKHR "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("chooseSwapSurfaceFormat")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<VkSurfaceFormatKHR>& availableFormats)")]),e._v(" ")]),e._v("{\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("for")]),e._v(" ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("auto")]),e._v("& availableFormat : availableFormats) {\n            "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {\n                "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("return")]),e._v(" availableFormat;\n            }\n        }\n\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("return")]),e._v(" availableFormats["),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("];\n")])]),t("h3",[t("a",{attrs:{name:"componentsswizzling"}}),e._v("components & swizzling")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;\ncreateInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;\ncreateInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;\ncreateInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;\n")])]),t("ul",[t("li",[e._v("Allows for color swizziling")]),t("li",[e._v("What's color swizziling?")])]),t("p",[e._v("In computer graphics, swizzling is the ability to compose vectors by arbitrarily rearranging and combining components of other vectors.")]),t("p",[e._v("For example, if "),t("code",{pre:!0},[e._v("A = {1,2,3,4}")]),e._v(", where the components are x, y, z, and w respectively, you could compute "),t("code",{pre:!0},[e._v("B = A.wwxy")]),e._v(", whereupon B would equal {4,4,1,2}. Additionally, combining two two-component vectors can create a four-component vector, or any combination of vectors and swizzling. This is common in GPGPU applications")]),t("h3",[t("a",{attrs:{name:"subresourceRange"}}),e._v("subresourceRange")]),t("p",[e._v("Describes which part of the image to access")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\ncreateInfo.subresourceRange.baseMipLevel = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\ncreateInfo.subresourceRange.levelCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\ncreateInfo.subresourceRange.baseArrayLayer = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\ncreateInfo.subresourceRange.layerCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\n")])]),t("p",[e._v("Above is no mipmapping or multiple layers")]),t("p",[e._v("Use multiple layers for "),t("code",{pre:!0},[e._v("steroscopic 3d applications")]),e._v(" https://en.wikipedia.org/wiki/Stereoscopy")]),t("h3",[t("a",{attrs:{name:"CreatingtheImageViewvkCreateImageView"}}),e._v("Creating the ImageView vkCreateImageView")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v('if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) {\n    throw std::runtime_error("failed to create image views!");\n}\n')])]),t("hr"),t("h2",[t("a",{attrs:{name:"GraphicsPipeline"}}),e._v("Graphics Pipeline")]),t("img",{attrs:{src:"img/gfxpipeline.png"}}),t("h3",[t("a",{attrs:{name:"InputAssembler"}}),e._v("Input Assembler")]),t("ul",[t("li",[e._v("Collect raw vertex data")]),t("li",[e._v("Can use an "),t("code",{pre:!0},[e._v("index buffer")]),e._v(" for duplicated vertex data")])]),t("h3",[t("a",{attrs:{name:"VertexShader"}}),e._v("Vertex Shader")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("Programmable")])]),t("li",[e._v("For every vertices applies transformations")]),t("li",[e._v("Vertex position to Screen Space")]),t("li",[e._v("Pass each vertices to next")])]),t("h3",[t("a",{attrs:{name:"TesselationShaders"}}),e._v("Tesselation Shaders")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("Programmable")])]),t("li",[e._v("Subdivide geometry based on "),t("code",{pre:!0},[e._v("rules")])]),t("li",[e._v("e.g. make surfaces look like brick walls, staircases look not flat")])]),t("h3",[t("a",{attrs:{name:"GeometryShader"}}),e._v("Geometry Shader")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("Programmable")])]),t("li",[e._v("Run on the incoming input primitive (point, triangle, line)")]),t("li",[e._v("discard things or create more primitives")]),t("li",[e._v("similar to the tesselation shader")]),t("li",[t("code",{pre:!0},[e._v("Performance is not good except on Intel's integrated GPU's")])])]),t("h3",[t("a",{attrs:{name:"Rasterisationstage"}}),e._v("Rasterisation stage")]),t("ul",[t("li",[e._v("From primitives into "),t("code",{pre:!0},[e._v("fragments")])]),t("li",[e._v("Pixel elements that fill on the "),t("code",{pre:!0},[e._v("framebuffer")])]),t("li",[e._v("This will discard any fragments that "),t("code",{pre:!0},[e._v("fall outside the screen")])]),t("li",[e._v("Attributes from the vertex shader is "),t("code",{pre:!0},[e._v("interpolated across fragments")])]),t("li",[e._v("Does "),t("code",{pre:!0},[e._v("Depth Testing")]),e._v(" anything behind other framgnets are discarded")])]),t("h3",[t("a",{attrs:{name:"FragmentShader"}}),e._v("Fragment Shader")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("Programmable")])]),t("li",[e._v("Fragments that survive in the framebuffers are "),t("code",{pre:!0},[e._v("written to and with a color and depth value")])]),t("li",[e._v("Interpolates data from the vertex shader including "),t("code",{pre:!0},[e._v("texture coodinates and normals for lighting")])])]),t("h3",[t("a",{attrs:{name:"ColorBlending"}}),e._v("Color Blending")]),t("ul",[t("li",[e._v("Mix different fragments that map to same pixel in framebuffer")])]),t("h2",[t("a",{attrs:{name:"GraphicsPipelineMutability"}}),e._v("Graphics Pipeline Mutability")]),t("h3",[t("a",{attrs:{name:"Immutable"}}),e._v("Immutable")]),t("p",[e._v("The graphics pipeline in Vulkan is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function")]),t("p",[e._v("You'll need to create many pipelines that will be used in the rendering operations")]),t("h3",[t("a",{attrs:{name:"ShadowMaps"}}),e._v("Shadow Maps")]),t("ul",[t("li",[e._v("When you would disable the fragment shader to produce shadows")]),t("li",[t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Shadow_mapping"}},[e._v("Wiki")])])]),t("hr"),t("h2",[t("a",{attrs:{name:"ShaderModules"}}),e._v("Shader Modules")]),t("h3",[t("a",{attrs:{name:"SPIR-V"}}),e._v("SPIR-V")]),t("ul",[t("li",[e._v("A bytecode format that can be used with "),t("code",{pre:!0},[e._v("Vulkan and OpenCL")])]),t("li",[e._v("Needs to be compiled (can be from GLSL or HLSL)")])]),t("h3",[t("a",{attrs:{name:"Whybytecode"}}),e._v("Why bytecode?")]),t("ul",[t("li",[e._v("Turning shader code into native code with bytecode is significantly less complex")])]),t("h3",[t("a",{attrs:{name:"ProblemswithGLSLHLSL"}}),e._v("Problems with GLSL/HLSL")]),t("ul",[t("li",[e._v("When shader code becomes quite big with syntax errors and is non trivial then "),t("code",{pre:!0},[e._v("vendor's drivers could reject your code")])])]),t("h3",[t("a",{attrs:{name:"CompilingvsRuntime"}}),e._v("Compiling vs Runtime")]),t("ul",[t("li",[e._v("Compile to see any issues")]),t("li",[e._v("Can also include a runtime library to produce spirv at runtime")])]),t("h3",[t("a",{attrs:{name:"Tools"}}),e._v("Tools")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("glslangValidator")])]),t("li",[t("code",{pre:!0},[e._v("glslc")]),e._v(" - GLSLc compiler")]),t("li",[e._v("You can use functionality like "),t("code",{pre:!0},[e._v("includes")]),e._v(" (nice!)")])]),t("h3",[t("a",{attrs:{name:"Glslbasics"}}),e._v("Glsl basics")]),t("ul",[t("li",[e._v("vec3 for vector 3")]),t("li",[e._v("vec3(1.0,2.0,3.0).xy produces a vec2")]),t("li",[e._v("Can compose vec3 and vec2 e.g. vec3(vec2(1,2), 1) to produce a vec3")])]),t("h3",[t("a",{attrs:{name:"VertexShader-1"}}),e._v("Vertex Shader")]),t("p",[e._v("Processes every vertex and passes attributes like color, texture coordinates, normals and produces a final position and the attributes")]),t("p",[e._v("passes to the rasterizer for interpolation over the fragments to produce a smooth gradient")]),t("h3",[t("a",{attrs:{name:"ClipCoordinateHomogeneousCoordinates"}}),e._v("Clip Coordinate & Homogeneous Coordinates")]),t("ul",[t("li",[e._v("Four dimensional vector from the vertex shader that is turned into a "),t("code",{pre:!0},[e._v("normalized device coordinate")]),e._v(" by "),t("code",{pre:!0},[e._v("dividing the vector by its last component")])]),t("li",[e._v("Setting the fourth component to 1 will not change anything")])]),t("p",[e._v('<img src="img/homogencoords.png/>')]),t("p",[e._v("Now the frame buffer has (0,0) in the middle and "),t("code",{pre:!0},[e._v("everything is between -1, 1")])]),t("h3",[t("a",{attrs:{name:"Z-Coordinate"}}),e._v("Z-Coordinate")]),t("ul",[t("li",[e._v("The Z coordinate now uses the same range as it does in Direct3D, from 0 to 1.")])]),t("h3",[t("a",{attrs:{name:"GL_ARB_separate_shader_objects"}}),e._v("GL_ARB_separate_shader_objects")]),t("ul",[t("li",[e._v("See "),t("a",{attrs:{href:"https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt"}},[e._v("here")])])]),t("h3",[t("a",{attrs:{name:"Sendingoutattributeswithlayout"}}),e._v("Sending out attributes with layout")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("layout(location = 0) out vec3 fragColor;\n")])]),t("p",[e._v("Where location = 0 specifies framebuffer 0")]),t("p",[e._v("Then in the main")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("main")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    gl_Position = vec4(positions[gl_VertexIndex], "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1.0")]),e._v(");\n    fragColor = colors[gl_VertexIndex];\n}\n")])]),t("h3",[t("a",{attrs:{name:"gl_Positionisaspecialattributefromvertexshader"}}),e._v("gl_Position is a special attribute from vertex shader")]),t("ul",[t("li",[e._v("Needs to be set and is vec 4")]),t("li",[e._v("Custom out parameter specified fragColor")])]),t("h3",[t("a",{attrs:{name:"inandoutparams"}}),e._v("in and out params")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-meta"}},[e._v("#version 450")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-meta"}},[e._v("#extension GL_ARB_separate_shader_objects : enable")]),e._v("\n\nlayout(location = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(") in vec3 fragColor;\n\nlayout(location = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(") out vec4 outColor;\n\n"),t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("main")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    outColor = vec4(fragColor, "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1.0")]),e._v(");\n}\n")])]),t("p",[e._v("Then coming in we have the layout being set and the in and out params")]),t("h2",[t("a",{attrs:{name:"ShaderModulesVKShaderModule"}}),e._v("ShaderModules (VKShaderModule)")]),t("ul",[t("li",[e._v("Create similar to above with createInfo builder pattern")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkShaderModuleCreateInfo createInfo{};\ncreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;\ncreateInfo.codeSize = code."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("();\ncreateInfo.pCode = "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("reinterpret_cast")]),e._v("<"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v("*>(code.data());\n")])]),t("ul",[t("li",[e._v("Where code is the readFile "),t("code",{pre:!0},[e._v("const std::vector<char>& code")])])]),t("h3",[t("a",{attrs:{name:"SPIRVuseinGraphicsPipeline"}}),e._v("SPIRV use in Graphics Pipeline")]),t("ul",[t("li",[e._v("Shader modules are a wrapper around the SPIRV bytecode")]),t("li",[t("code",{pre:!0},[e._v("Compilation and Linking")]),e._v(" of this bytecode happens when graphics pipeline is created")]),t("li",[e._v("Shader modules Can be destroyed as soon as this is done")]),t("li",[e._v("i.e. call this as soon as Grpahics pipeline init done")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("    vkDestroyShaderModule(device, fragShaderModule, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(");\n    vkDestroyShaderModule(device, vertShaderModule, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(");\n")])]),t("h3",[t("a",{attrs:{name:"VkPipelineShaderStageCreateInfo"}}),e._v("VkPipelineShaderStageCreateInfo")]),t("ul",[t("li",[e._v("We actually need to create Vertex & Fragment shader stages manually")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n        VkPipelineShaderStageCreateInfo vertShaderStageInfo{};\n        vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;\n        vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;\n        vertShaderStageInfo."),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("module")]),e._v(" = vertShaderModule;\n        vertShaderStageInfo.pName = "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"main"')]),e._v(";\n")])]),t("h3",[t("a",{attrs:{name:"pSpecializationInfo"}}),e._v("pSpecializationInfo")]),t("ul",[t("li",[e._v("This is something you can add to the ShaderStageInfo")]),t("li",[e._v("Allows you to specify "),t("code",{pre:!0},[e._v("values for shader constants")])]),t("li",[e._v("e.g. you can load a shader stage with default preconfigured values")]),t("li",[e._v("This is more efficient than variables needed at render time")])]),t("hr"),t("h2",[t("a",{attrs:{name:"Fixedfunctions"}}),e._v("Fixed functions")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions"}},[e._v("Docs: Fixed Functions")])])]),t("h3",[t("a",{attrs:{name:"VertexInput"}}),e._v("Vertex Input")]),t("ul",[t("li",[e._v("Structure: "),t("code",{pre:!0},[e._v("VkPipelineVertexInputStateCreateInfo")])]),t("li",[e._v("in createGraphicsPipeline")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("\n        VkPipelineVertexInputStateCreateInfo vertexInputInfo{};\n        vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;\n        vertexInputInfo.vertexBindingDescriptionCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n        vertexInputInfo.pVertexBindingDescriptions = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n        vertexInputInfo.vertexAttributeDescriptionCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\n        vertexInputInfo.pVertexAttributeDescriptions = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n")])]),t("ul",[t("li",[e._v("Details for VertexBuffer in "),t("code",{pre:!0},[e._v("pVertexBindingDescriptions")])]),t("li",[e._v("Details for VertexBuffer Attributes in "),t("code",{pre:!0},[e._v("pVertexAttributeDescriptions")])])]),t("h3",[t("a",{attrs:{name:"VkPipelineInputAssemblyStateCreateInfo"}}),e._v("VkPipelineInputAssemblyStateCreateInfo")]),t("ul",[t("li",[e._v("What does this describe? "),t("ul",[t("li",[e._v("What kind of geometry? "),t("code",{pre:!0},[e._v("Point List, Line List, Triangle List, Triangle Strip")])]),t("li",[e._v("Specify which indices to use as attributes i.e. if color first then position")]),t("li",[e._v("Optimizations like reusing vertices with "),t("code",{pre:!0},[e._v("primitiveRestartEnable")]),e._v(" = "),t("code",{pre:!0},[e._v("VK_TRUE")]),t("ul",[t("li",[e._v("This will breka up lines in _STRIP topology")])])])])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPipelineInputAssemblyStateCreateInfo inputAssembly{};\ninputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;\ninputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;\ninputAssembly.primitiveRestartEnable = VK_FALSE;\n")])]),t("h3",[t("a",{attrs:{name:"ViewPortsandScissors"}}),e._v("ViewPorts and Scissors")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("VKViewport")])]),t("li",[e._v("Viewport described a region of the framebuffer the output will be rendered to")]),t("li",[e._v("Almost always be (0, 0) to (width, height)")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkViewport viewport{};\nviewport.x = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(";\nviewport.y = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(";\nviewport."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("width")]),e._v(" = ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("float")]),e._v(") swapChainExtent."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("width")]),e._v(";\nviewport."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("height")]),e._v(" = ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("float")]),e._v(") swapChainExtent."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("height")]),e._v(";\nviewport.minDepth = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(";\nviewport.maxDepth = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1.0f")]),e._v(";\n")])]),t("ul",[t("li",[e._v("Note that swapChainExtent.width/height is used as this may different from the size of the window.")])]),t("h3",[t("a",{attrs:{name:"FilteringimagewithScissorRectanglesViewport"}}),e._v("Filtering image with Scissor Rectangles + Viewport")]),t("img",{attrs:{src:"img/scissor.png"}}),t("ul",[t("li",[e._v("View ports define transformation from image to framebuffer / scissor rectangles")]),t("li",[e._v("Any pixels outside the recttangle will be discarded")])]),t("p",[e._v("Defining a Scissor")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkRect2D scissor{};\nscissor.offset = {"),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("};\nscissor.extent = swapChainExtent;\n\n....\nVkPipelineViewportStateCreateInfo viewportState{};\nviewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;\nviewportState.viewportCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nviewportState.pViewports = &viewport;\nviewportState.scissorCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nviewportState.pScissors = &scissor;\n")])]),t("h3",[t("a",{attrs:{name:"Rasterizer"}}),e._v("Rasterizer")]),t("ul",[t("li",[e._v("Fragments from vertex shader into color")]),t("li",[e._v("Does depth testing and face culling and scissor test")]),t("li",[e._v("Can do wireframe rendering")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPipelineRasterizationStateCreateInfo rasterizer{};\nrasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;\nrasterizer.depthClampEnable = VK_FALSE;\nrasterizer.polygonMode = VK_POLYGON_MODE_FILL;\n")])]),t("h3",[t("a",{attrs:{name:"Nonfillmodesneed"}}),e._v("Non fill modes need")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("rasterizer.lineWidth = 1.0f;\n")])]),t("h3",[t("a",{attrs:{name:"Faceculling"}}),e._v("Face culling")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;\nrasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;\n")])]),t("h3",[t("a",{attrs:{name:"Depthproperties"}}),e._v("Depth properties")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("rasterizer.depthBiasEnable = VK_FALSE;\nrasterizer.depthBiasConstantFactor = 0.0f; // Optional\nrasterizer.depthBiasClamp = 0.0f; // Optional\nrasterizer.depthBiasSlopeFactor = 0.0f; // Optional\n")])]),t("h3",[t("a",{attrs:{name:"Multisamplingforanti-aliasing"}}),e._v("Multisampling for anti-aliasing")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPipelineMultisampleStateCreateInfo multisampling{};\nmultisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;\nmultisampling.sampleShadingEnable = VK_FALSE;\nmultisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;\nmultisampling.minSampleShading = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1.0f")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\nmultisampling.pSampleMask = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\nmultisampling.alphaToCoverageEnable = VK_FALSE; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\nmultisampling.alphaToOneEnable = VK_FALSE; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n")])]),t("ul",[t("li",[e._v("How: It works by combining the fragment shader results of multiple polygons that rasterize to the same pixel.")]),t("li",[e._v("Primarily on edges")])]),t("h3",[t("a",{attrs:{name:"Depthandstenciltesting"}}),e._v("Depth and stencil testing")]),t("ul",[t("li",[t("code",{pre:!0},[e._v("VkPipelineDepthStencilStateCreateInfo")])])]),t("h3",[t("a",{attrs:{name:"ColorBlending-1"}}),e._v("Color Blending")]),t("ul",[t("li",[e._v("modifying the color in a specific framebuffer pixel lolcation")]),t("li",[e._v("Mix the old and new or combine the old and new using a bitwise operation")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPipelineColorBlendAttachmentState colorBlendAttachment{};\ncolorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;\ncolorBlendAttachment.blendEnable = VK_FALSE;\ncolorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\ncolorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\ncolorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\ncolorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\ncolorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\ncolorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n")])]),t("h3",[t("a",{attrs:{name:"DynamicStatechangingpipelinewithoutrestart"}}),e._v("Dynamic State (changing pipeline without restart)")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkDynamicState dynamicStates[] = {\n    VK_DYNAMIC_STATE_VIEWPORT,\n    VK_DYNAMIC_STATE_LINE_WIDTH\n};\n\nVkPipelineDynamicStateCreateInfo dynamicState{};\ndynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;\ndynamicState.dynamicStateCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("2")]),e._v(";\ndynamicState.pDynamicStates = dynamicStates;\n")])]),t("h3",[t("a",{attrs:{name:"Pipelinelayout"}}),e._v("Pipeline layout")]),t("ul",[t("li",[e._v("For passing uniform values in shaders which act as globals")]),t("li",[e._v("Neede at pipeline cration")]),t("li",[t("code",{pre:!0},[e._v("VkPipelineLayout pipelineLayout;")])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkPipelineLayoutCreateInfo pipelineLayoutInfo{};\npipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;\npipelineLayoutInfo.setLayoutCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\npipelineLayoutInfo.pSetLayouts = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\npipelineLayoutInfo.pushConstantRangeCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\npipelineLayoutInfo.pPushConstantRanges = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkCreatePipelineLayout(device, &pipelineLayoutInfo, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &pipelineLayout) != VK_SUCCESS) {\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create pipeline layout!"')]),e._v(");\n}\n")])]),t("ul",[t("li",[e._v("Make sure to cleanup this pipeline layout")])]),t("hr"),t("h2",[t("a",{attrs:{name:"RenderPasses"}}),e._v("Render Passes")]),t("ul",[t("li",[t("a",{attrs:{href:"https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes"}},[e._v("Docs: Render Passes")])])]),t("p",[e._v("All about the framebuffer setup and attaching it to the pipeline")]),t("p",[e._v("THis needs to happen before the pipeline is created")]),t("p",[e._v("What we'll need to specify is: We need to specify how many color and depth buffers there will be, how many samples to use for each of them and how their contents should be handled throughout the rendering operations.")]),t("h3",[t("a",{attrs:{name:"SingleColorBufferattachment"}}),e._v("Single Color Buffer attachment")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("createRenderPass")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    VkAttachmentDescription colorAttachment{};\n    colorAttachment.format = swapChainImageFormat;\n    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;\n    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;\n    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;\n}\n")])]),t("ul",[t("li",[e._v("loadOp determines what to do with the data before rendering and after rendering")]),t("li",[e._v("Options:")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VK_ATTACHMENT_LOAD_OP_LOAD: Preserve the existing contents of the attachment\nVK_ATTACHMENT_LOAD_OP_CLEAR: Clear the values to a constant at the start\nVK_ATTACHMENT_LOAD_OP_DONT_CARE: Existing contents are undefined; we don't care about them\n")])]),t("ul",[t("li",[e._v("storeOp determines whether we want to store the data for later")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VK_ATTACHMENT_STORE_OP_STORE: Rendered contents will be stored in memory and can be read later\nVK_ATTACHMENT_STORE_OP_DONT_CARE: Contents of the framebuffer will be undefined after the rendering operation\n")])]),t("h3",[t("a",{attrs:{name:"Triangle"}}),e._v("Triangle")]),t("ul",[t("li",[e._v("For the triangle we want to load and clear the data to a black screen and store the data")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;\ncolorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;\n")])]),t("h3",[t("a",{attrs:{name:"ColorAttachmentLayout"}}),e._v("Color Attachment Layout")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;\ncolorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;\n")])]),t("ul",[t("li",[e._v("There's a certain pixel format for Textures / Frame Buffers in a VKImage but the layout may change")])]),t("p",[e._v("Some layouts")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: Images used as color attachment\nVK_IMAGE_LAYOUT_PRESENT_SRC_KHR: Images to be presented in the swap chain\nVK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: Images to be used as destination for a memory copy operation\n\n")])]),t("h4",[t("a",{attrs:{name:"InitialLayout"}}),e._v("Initial Layout")]),t("p",[e._v("The initialLayout specifies which layout the image will have before the render pass begin")]),t("p",[t("code",{pre:!0},[e._v("VK_IMAGE_LAYOUT_UNDEFINED")]),e._v(" means we don't care what the previous layout was")]),t("h3",[t("a",{attrs:{name:"FinalLayout"}}),e._v("Final Layout")]),t("p",[e._v("The finalLayout specifies the layout to automatically transition to when the render pass finishes")]),t("h3",[t("a",{attrs:{name:"Subpassesandattachmentreferences"}}),e._v("Subpasses and attachment references")]),t("ul",[t("li",[e._v("Subpasses are subsequent rendering operations that depend on the framebuffers previous passes")]),t("li",[e._v("e.g. post processing effects")]),t("li",[e._v("If you group these rendering operations into one render pass")]),t("li",[e._v("then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkAttachmentReference colorAttachmentRef{};\ncolorAttachmentRef.attachment = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\ncolorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;\n")])]),t("h3",[t("a",{attrs:{name:"attachment"}}),e._v("attachment")]),t("ul",[t("li",[e._v("The attachment parameter specifies which attachment to reference by its index in the attachment descriptions array.")])]),t("h3",[t("a",{attrs:{name:"SubpassDescription"}}),e._v("Subpass Description")]),t("ul",[t("li",[e._v("This could be compute subpasses in the future")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkSubpassDescription subpass{};\nsubpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;\n")])]),t("ul",[t("li",[e._v("Add the reference to the color attachment")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("subpass.colorAttachmentCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nsubpass.pColorAttachments = &colorAttachmentRef;\n")])]),t("p",[e._v("The index of the attachment in this array is directly referenced from the fragment shader")]),t("ul",[t("li",[e._v("with the layout(location = 0) out vec4 outColor directive!")])]),t("h3",[t("a",{attrs:{name:"OtherattachmentTypes"}}),e._v("Other attachment Types")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("pInputAttachments: Attachments that are read from a shader\npResolveAttachments: Attachments used for multisampling color attachments\npDepthStencilAttachment: Attachment for depth and stencil data\npPreserveAttachments: Attachments that are not used by this subpass, but for which the data must be preserved\n")])]),t("h2",[t("a",{attrs:{name:"RenderPass"}}),e._v("Render Pass")]),t("ul",[t("li",[e._v("New variables added to the app")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VkRenderPass renderPass;\nVkPipelineLayout pipelineLayout;\n")])]),t("ul",[t("li",[e._v("We will add array of attachments and subpasses and describe it with "),t("code",{pre:!0},[e._v("VKRenderPassCreateInfo")])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkRenderPassCreateInfo renderPassInfo{};\nrenderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;\nrenderPassInfo.attachmentCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nrenderPassInfo.pAttachments = &colorAttachment;\nrenderPassInfo.subpassCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nrenderPassInfo.pSubpasses = &subpass;\n\n"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkCreateRenderPass(device, &renderPassInfo, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &renderPass) != VK_SUCCESS) {\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create render pass!"')]),e._v(");\n}\n")])]),t("ul",[t("li",[e._v("You will need to cleanup the pipeline layout and render pass")])]),t("hr"),t("h2",[t("a",{attrs:{name:"Drawing:FrameBuffers"}}),e._v("Drawing: Frame Buffers")]),t("ul",[t("li",[e._v("Framebuffers contain all of the VKimageView objects that represent the attachments")]),t("li",[e._v("The only attachment we have for the triangle is the "),t("code",{pre:!0},[e._v("color attachment")])]),t("li",[e._v("Which VKImageView to use depends on the image the "),t("code",{pre:!0},[e._v("swap chain returns")]),e._v(" for presentation")]),t("li",[e._v("So we can have a framebuffer for all images in the swap chain and use the one that corresponds to the retrieved image adt drawing")])]),t("h3",[t("a",{attrs:{name:"FrameBuffercontains"}}),e._v("FrameBuffer contains")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("vector")]),e._v("<VkFramebuffer> swapChainFramebuffers;\n")])]),t("ul",[t("li",[e._v("We can createFramebuffers after creating the Graphics Pipeline")])]),t("h3",[t("a",{attrs:{name:"CreatingFrameBuffersfromImageViews"}}),e._v("Creating FrameBuffers from ImageViews")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("for")]),e._v(" ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("size_t")]),e._v(" i = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; i < swapChainImageViews."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("(); i++) {\n    VkImageView attachments[] = {\n        swapChainImageViews[i]\n    };\n\n    VkFramebufferCreateInfo framebufferInfo{};\n    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;\n    framebufferInfo.renderPass = renderPass;\n    framebufferInfo.attachmentCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\n    framebufferInfo.pAttachments = attachments;\n    framebufferInfo."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("width")]),e._v(" = swapChainExtent."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("width")]),e._v(";\n    framebufferInfo."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("height")]),e._v(" = swapChainExtent."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("height")]),e._v(";\n    framebufferInfo.layers = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\n\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkCreateFramebuffer(device, &framebufferInfo, "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v(", &swapChainFramebuffers[i]) != VK_SUCCESS) {\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to create framebuffer!"')]),e._v(");\n    }\n}\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"CommandBuffers"}}),e._v("Command Buffers")]),t("ul",[t("li",[e._v("Vector of command buffers "),t("code",{pre:!0},[e._v("VkCommandBuffer")])]),t("li",[e._v("Size would be resized to swapChainFrameBuffers size "),t("code",{pre:!0},[e._v("commandbuffers.resize(swapChainFramebuffers.size())")])]),t("li",[e._v("Make a Command Buffer with "),t("code",{pre:!0},[e._v("vkAllocateCommandBuffers")])]),t("li",[e._v("Builder patter with "),t("code",{pre:!0},[e._v("VkCommandBufferAllocateInfo")])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkCommandBufferAllocateInfo allocInfo{};\nallocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;\nallocInfo.commandPool = commandPool;\nallocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;\nallocInfo.commandBufferCount = ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("uint32_t")]),e._v(") commandBuffers."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("();\n\n"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to allocate command buffers!"')]),e._v(");\n}\n")])]),t("h3",[t("a",{attrs:{name:"PrimarySecondarycommandbuffer"}}),e._v("Primary / Secondary command buffer?")]),t("ul",[t("li",[e._v("Primary: Can be submitted to queue for executation but not called by other command buffers")]),t("li",[e._v("Secondary: Cannot be submitted directly but can be called from primary command buffers")])]),t("h3",[t("a",{attrs:{name:"CommandBufferRecording"}}),e._v("Command Buffer Recording")]),t("ul",[t("li",[e._v("Begin with "),t("code",{pre:!0},[e._v("vkBeginCommandBuffer")])])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("for")]),e._v(" ("),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("size_t")]),e._v(" i = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; i < commandBuffers."),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("size")]),e._v("(); i++) {\n    VkCommandBufferBeginInfo beginInfo{};\n    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;\n    beginInfo.flags = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n    beginInfo.pInheritanceInfo = "),t("span",{pre:!0,attrs:{class:"hljs-literal"}},[e._v("nullptr")]),e._v("; "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Optional")]),e._v("\n\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkBeginCommandBuffer(commandBuffers[i], &beginInfo) != VK_SUCCESS) {\n        "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to begin recording command buffer!"')]),e._v(");\n    }\n}\n")])]),t("ul",[t("li",[e._v("flags is how we are going to use the command buffer")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: The command buffer will be rerecorded right after executing it once.\nVK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: This is a secondary command buffer that will be entirely within a single render pass.\nVK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: The command buffer can be resubmitted while it is also already pending execution.\n")])]),t("ul",[t("li",[e._v("pInheritanceInfo - only relevant for "),t("code",{pre:!0},[e._v("secondary command buffers")])])]),t("h3",[t("a",{attrs:{name:"StartRenderPass"}}),e._v("Start Render Pass")]),t("ul",[t("li",[e._v("Begin with "),t("code",{pre:!0},[e._v("vkCmdBeginRenderPass")]),e._v(" and configure with "),t("code",{pre:!0},[e._v("VkRenderPassBeginInfo")]),e._v(" struct")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Builder Struct")]),e._v("\nVkRenderPassBeginInfo renderPassInfo{};\nrenderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Pass the renderPass and framebuffer")]),e._v("\nrenderPassInfo.renderPass = renderPass;\nrenderPassInfo.framebuffer = swapChainFramebuffers[i];\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Size of the render area")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Defines where shader loads and stores and should match size of attachments")]),e._v("\nrenderPassInfo.renderArea.offset = {"),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("};\nrenderPassInfo.renderArea.extent = swapChainExtent;\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Clear color ")]),e._v("\nVkClearValue clearColor = {"),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0.0f")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1.0f")]),e._v("};\nrenderPassInfo.clearValueCount = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(";\nrenderPassInfo.pClearValues = &clearColor;\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Call cmd begin render pass")]),e._v("\nvkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);\n")])]),t("h3",[t("a",{attrs:{name:"RenderPassvkCmd-BeginDrawingCommand"}}),e._v("Render Pass vkCmd - Begin Drawing Command")]),t("p",[e._v("We need to specify the commandbuffer and also bind the graphics pipeline")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);\nvkCmdDraw(commandBuffers[i], "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("3")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("1")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(", "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(");\n")])]),t("p",[e._v("vkCmdDraw Parameters")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":""}},[e._v("commandbuffer: commandbuffer\nvertexCount: Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.\ninstanceCount: Used for instanced rendering, use 1 if you're not doing that.\nfirstVertex: Used as an offset into the vertex buffer, defines the lowest value of gl_VertexIndex.\nfirstInstance: Used as an offset for instanced rendering, defines the lowest value of gl_InstanceIndex.\n")])]),t("h3",[t("a",{attrs:{name:"EndingtheRenderPassCmd"}}),e._v("Ending the Render Pass Cmd")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("vkCmdEndRenderPass(commandBuffers[i]);\n"),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("if")]),e._v(" (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) {\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("throw")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::runtime_error("),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"failed to record command buffer!"')]),e._v(");\n}\n")])]),t("hr"),t("h2",[t("a",{attrs:{name:"VertexBuffers"}}),e._v("Vertex Buffers")]),t("p",[e._v("We can now create our triangle via a struct like so with glm")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-class"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("struct")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("Vertex")]),e._v(" {")]),e._v("\n    glm::vec2 pos;\n    glm::vec3 color;\n};\n")])]),t("h3",[t("a",{attrs:{name:"NeedtospecifytheBindingDescription"}}),e._v("Need to specify the "),t("code",{pre:!0},[e._v("Binding Description")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("VkVertexInputBindingDescription bindingDescription{}; \nbindingDescription.binding = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";\t\t\t\t\t\t\t\t"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Specifies the index of the binding")]),e._v("\nbindingDescription.stride = "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("sizeof")]),e._v("(Vertex);\t\t\t\t\t"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Number of bytes for a single entry")]),e._v("\nbindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;\t"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Move after next instance / data ")]),e._v("\n")])]),t("h3",[t("a",{attrs:{name:"AttributeDescription"}}),e._v("Attribute Description")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-function"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("static")]),e._v(" "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("array")]),e._v("<VkVertexInputAttributeDescription, 2> "),t("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("getAttributeDescriptions")]),t("span",{pre:!0,attrs:{class:"hljs-params"}},[e._v("()")]),e._v(" ")]),e._v("{\n    "),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("std")]),e._v("::"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("array")]),e._v("<VkVertexInputAttributeDescription, 2> attributeDescriptions{};\n\n    "),t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("return")]),e._v(" attributeDescriptions;\n}\n")])]),t("ul",[t("li",[e._v("This will describe how to extract a vertex attribute from the "),t("code",{pre:!0},[e._v("Vertex")]),e._v(" data")]),t("li",[e._v("Curtrently we have color and position")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[e._v("attributeDescriptions["),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("].binding = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";                       "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Which has the per vertex-data ")]),e._v("\nattributeDescriptions["),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("].location = "),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v(";                      "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Location refers to the location param in the shader code")]),e._v("\nattributeDescriptions["),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("].format = VK_FORMAT_R32G32_SFLOAT;  "),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("// Whats the type for the data attribute since we're vec2 we can use R32G32")]),e._v("\nattributeDescriptions["),t("span",{pre:!0,attrs:{class:"hljs-number"}},[e._v("0")]),e._v("].offset = offsetof(Vertex, pos);\n")])]),t("ul",[t("li",[e._v("Common datas types")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-c++"}},[t("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("float")]),e._v(": VK_FORMAT_R32_SFLOAT\nvec2: VK_FORMAT_R32G32_SFLOAT\nvec3: VK_FORMAT_R32G32B32_SFLOAT\nvec4: VK_FORMAT_R32G32B32A32_SFLOAT\n")])])])}],n=t("2877"),i={},l=Object(n["a"])(i,s,r,!1,null,null,null);a["default"]=l.exports}}]);