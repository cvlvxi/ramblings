# Back to the assembler

Ever wondered how x86 assembly works? 

Well a good starting place to understand how x86 assembly works is to go from `C to assembly and from assembly to C`. It's basically like that movie with a Fly named Marty.

<img src="https://i.ytimg.com/vi/k0kswK2aI08/maxresdefault.jpg"/>


Assuming you have a C compiler installed we make use of the nifty `-S` argument to compile a `main.c` file into assembly code. I'm using this hacky Makefile to do the trick

Makefile

```Makefile
TARGET=main
CC=clang
DEBUGGER=lldb

run: build
	./bin/$(TARGET)

buildasm: 
	$(CC) $(TARGET).c -g -S -O0 -o asm/$(TARGET).S

asmtoo: buildasm
	$(CC) -c asm/$(TARGET).S -o o/$(TARGET).o;

build: asmtoo
	$(CC) o/$(TARGET).o -g -o bin/$(TARGET);

mkdirs:
	mkdir -p asm
	mkdir -p bin
	mkdir -p o

clean:
	rm bin/*; rm o/*; rm asm/*;

debug: 
	$(DEBUGGER) bin/main

```

And with a corresponding main.c file to compile

```c
#include <stdio.h>

void doSomething(int dog) {
    int a = 0x456;
}

int main(void) {
    int a = 0x123;
    doSomething(4);
    printf("Hello World");
    return 0;
}
```

We can now run `make run` and get the following output:

```
clang main.c -g -S -O0 -o asm/main.S
clang -c asm/main.S -o o/main.o;
clang o/main.o -g -o bin/main;
./bin/main
Hello World% 
```

Sweet so we now have something in our asm/ folder: `main.S` that contains the assembly instructions for above and as we can see we are also building a `main.o` file from that and creating a binary which did exactly what the `main.c` did.

That's cool.

This combined with debugging which i'll cover in another topic will get us slower to understanding the machine.

And by understanding the machine we are one step further to becoming:

<img src="https://media.giphy.com/media/Pqp4Y64TcGwJa/giphy.gif"/>

THE ONE.

